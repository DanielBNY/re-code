==============================
        Collections
==============================

Node Metadata - collection 1
point to nodes: nodes
cluster: cluster id
father id
Node size

node closest fathers - collection 2
father node: node
sons nodes: nodes

clusters - collection 3
cluster id
nodes in cluster: nodes
cluster size


files - collection 4
file id
cluster id

------------------------------------------------------------------------------------------------------

Find closest fathers of nodes
-----------------------------

init(first node)
    returned directed neighbors = tag_sons_of_nodes(first node)
    depth = 1
    while returned directed neighbors
        returned directed neighbors = tag_sons_of_nodes(returned directed neighbors)
        depth += 1

tag_sons_with_close_fathers(current_node, directed_neighbors)
    for node in directed_neighbors
        if node do not have a close father
            set node close father to the current node - in collection 2

tag_sons_of_nodes(nodes)
    for node in nodes
        directed_neighbors = get nodes that current_node point to
        all nodes directed neighbors += directed_neighbors
        tag_sons_with_close_fathers(node, directed_neighbors)
    return all nodes directed neighbors



------------------------------------------------------------------------------------------------------

Clustering functions, files and folders
---------------------------------------


Cluster graph
-------------

cluster graph(father nodes, graph, max file size, number of max files in folder, cluster files \ cluster functions)
    get average size of all nodes in graph
    if average is bigger than max size
        set max size to the node size average
    if cluster files
        max size * number of max files in folder
    for father node in father nodes
        get sum of sons clusters (remove duplicate clusters from nodes in the same cluster)
        if sum of sons clusters smaller than max cluster size
            if bigger than half of max cluster size
                merge clusters(sons of father clusters)
            else
                if sons clusters size plus close_father cluster size is smaller than max cluster size
                    merge first cluster to second cluster(sons of father cluster, father cluster)
                else
                    merge clusters(sons of father clusters)
        else if sum of sons clusters is bigger or equal to max cluster size
            number of clusters to divide into = (sum of sons clusters / max cluster size) + 1
            divide to clusters(number of clusters to divide into, sons of father)



(percent %) of max cluster size

0%       50%          100%          200%          300%   ...    100n%
O--------O-------------O-------------O-------------O-------------O-------------O >
1 cluster   1 cluster    2 clusters      3 clusters        ...         n clusters