==============================
        Collections
==============================

Node Metadata - collection 1
point to nodes: nodes
cluster id
closest father id
Node size

node closest fathers - collection 2
father node: node

clusters - collection 3
cluster id
nodes in cluster: nodes
cluster size


files - collection 4
file id
cluster id

------------------------------------------------------------------------------------------------------

Algorithm 1: Create a tree from functions calls graph
             -----------------------------------------

Description:
-----------
Recursively scans at the same level for nodes and if they do not have a close father they are tagged
by the first father, edges to already tagged nodes are removed.


semi code:
---------
init(first node, graph)
    neighbors_to_revisit = tag_sons_of_nodes(first node, graph)
    while list of neighbors_to_revisit is not empty
        neighbors_to_revisit = tag_sons_of_nodes(returned directed neighbors, graph)

tag_sons_with_close_fathers(current_node, directed_neighbors, graph)
    for neighbor_node in directed_neighbors
        if neighbor_node does not have a tagged close father
            set neighbor_node close father to the current node - in collection 2
            neighbors_to_revisit += neighbor_node
        else
            remove edge to already visited node
    return neighbors_to_revisit

tag_sons_of_nodes(nodes, graph)
    for node in nodes
        directed_neighbors = get nodes that current_node point to
        append to the list of neighbors_to_revisit the returned neighbors from function
                                                                tag_sons_with_close_fathers(node, directed_neighbors)
    return neighbors_to_revisit


------------------------------------------------------------------------------------------------------


Clustering functions, files and folders
---------------------------------------


Cluster graph
-------------

cluster graph(father nodes, graph, max file size, number of max files in folder, cluster files \ cluster functions)
    get average size of all nodes in graph
    enter each node to a cluster with his size
    if average is bigger than max size
        set max size to the node size average
    if cluster files
        max size * number of max files in folder
    for father node in father nodes
        get sum of sons clusters (remove duplicate clusters from nodes in the same cluster)
        if sum of sons clusters smaller than max cluster size
            if bigger than half of max cluster size
                merge clusters(sons of father clusters)
            else
                if sons clusters size plus close_father cluster size is smaller than max cluster size
                    merge first cluster to second cluster(sons of father cluster, father cluster)
                else
                    merge clusters(sons of father clusters)
        else if sum of sons clusters is bigger or equal to max cluster size
            number of clusters to divide into = (sum of sons clusters / max cluster size) + 1
            divide to clusters(number of clusters to divide into, sons of father)



(percent %) of max cluster size

0%       50%          100%          200%          300%   ...    100n%
O--------O-------------O-------------O-------------O-------------O-------------O >
1 cluster   1 cluster    2 clusters      3 clusters        ...         n clusters